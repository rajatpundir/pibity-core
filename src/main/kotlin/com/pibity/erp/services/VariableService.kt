/* 
 * Copyright (C) 2020 Pibity Infotech Private Limited - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 * THIS IS UNPUBLISHED PROPRIETARY CODE OF PIBITY INFOTECH PRIVATE LIMITED
 * The copyright notice above does not evidence any actual or intended publication of such source code.
 */

package com.pibity.erp.services

import com.google.gson.JsonArray
import com.google.gson.JsonObject
import com.pibity.erp.commons.*
import com.pibity.erp.commons.constants.GLOBAL_TYPE
import com.pibity.erp.commons.constants.KeyConstants
import com.pibity.erp.commons.constants.TypeConstants
import com.pibity.erp.commons.exceptions.CustomJsonException
import com.pibity.erp.entities.*
import com.pibity.erp.entities.embeddables.ValueId
import com.pibity.erp.entities.embeddables.VariableId
import com.pibity.erp.repositories.TypeRepository
import com.pibity.erp.repositories.VariableListRepository
import com.pibity.erp.repositories.VariableRepository
import org.codehaus.janino.ExpressionEvaluator
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class VariableService(
    val variableRepository: VariableRepository,
    val variableListRepository: VariableListRepository,
    val userService: UserService
) {

  @Transactional(rollbackFor = [CustomJsonException::class])
  fun createVariable(jsonParams: JsonObject, variableSuperList: VariableList? = null, variableTypePermission: TypePermission? = null): Variable {
    val typePermission: TypePermission = variableTypePermission
        ?: userService.superimposeUserPermissions(jsonParams = JsonObject().apply {
          addProperty("organization", jsonParams.get("organization").asString)
          addProperty("username", jsonParams.get("username").asString)
          addProperty("typeName", jsonParams.get("typeName").asString)
        })
    if (typePermission.id.type.id.superTypeName == GLOBAL_TYPE && !typePermission.creatable)
      throw CustomJsonException("{error: 'Unauthorized Access'}")
    val variableName: String = jsonParams.get("variableName").asString
    val type: Type = typePermission.id.type
    val superList: VariableList = variableSuperList ?: type.id.organization.superList!!
    val values: JsonObject = validateVariableValues(values = jsonParams.get("values").asJsonObject, typePermission = typePermission)
    val variable = Variable(id = VariableId(superList = superList, type = type, name = if (type.id.superTypeName == GLOBAL_TYPE && type.autoAssignId) (type.autoIncrementId + 1).toString() else variableName), autoGeneratedId = type.autoIncrementId + 1, subList = if (type.id.superTypeName == GLOBAL_TYPE) variableListRepository.save(VariableList(listType = type.id.organization.superList!!.listType)) else variableSuperList!!)
    variable.id.type.autoIncrementId += 1
    variable.id.type.variableCount += 1
    // Process non-formula type values
    typePermission.keyPermissions.filter { it.id.key.type.id.name != TypeConstants.FORMULA }.forEach { keyPermission ->
      val key = keyPermission.id.key
      when (key.type.id.name) {
        TypeConstants.TEXT -> variable.values.add(Value(id = ValueId(variable = variable, key = key), stringValue = values.get(key.id.name).asString))
        TypeConstants.NUMBER -> variable.values.add(Value(id = ValueId(variable = variable, key = key), longValue = values.get(key.id.name).asLong))
        TypeConstants.DECIMAL -> variable.values.add(Value(id = ValueId(variable = variable, key = key), doubleValue = values.get(key.id.name).asDouble))
        TypeConstants.BOOLEAN -> variable.values.add(Value(id = ValueId(variable = variable, key = key), booleanValue = values.get(key.id.name).asBoolean))
        TypeConstants.FORMULA -> {/* Formulas may depend on provided values, so they will be computed separately */
        }
        TypeConstants.LIST -> {
          val jsonArray: JsonArray = values.get(key.id.name).asJsonArray
          val list: VariableList = try {
            variableListRepository.save(VariableList(listType = key.list!!))
          } catch (exception: Exception) {
            throw CustomJsonException("{${key.id.name}: 'Unable to create List'}")
          }
          for (ref in jsonArray.iterator()) {
            if (key.list!!.type.id.superTypeName == GLOBAL_TYPE) {
              val referencedVariable: Variable = variableRepository.findByTypeAndName(superList = type.id.organization.superList!!, type = key.list!!.type, name = ref.asString)
                  ?: throw CustomJsonException("{${key.id.name}: 'Unable to find referenced global variable'}")
              referencedVariable.referenceCount += 1
              if (referencedVariable.id.type.multiplicity != 0L && referencedVariable.referenceCount > referencedVariable.id.type.multiplicity)
                throw CustomJsonException("{${key.id.name}: 'Unable to reference variable due to variable's reference limit'}")
              if (!referencedVariable.active)
                throw CustomJsonException("{${key.id.name}: 'Unable to reference variable as it is inactive'}")
              list.variables.add(referencedVariable)
              list.size += 1
            } else {
              if ((key.id.parentType.id.superTypeName == GLOBAL_TYPE && key.id.parentType.id.name == key.list!!.type.id.superTypeName)
                  || (key.id.parentType.id.superTypeName != GLOBAL_TYPE && key.id.parentType.id.superTypeName == key.list!!.type.id.superTypeName)) {
                val referencedVariable: Variable = try {
                  createVariable(JsonObject().apply {
                    addProperty("variableName", ref.asJsonObject.get("variableName").asString)
                    add("values", ref.asJsonObject.get("values").asJsonObject)
                  }, variableTypePermission = keyPermission.referencedTypePermission!!, variableSuperList = list)
                } catch (exception: CustomJsonException) {
                  throw CustomJsonException("{${key.id.name}: ${exception.message}}")
                }
                referencedVariable.referenceCount += 1
                list.variables.add(referencedVariable)
                list.size += 1
              } else {
                val referencedVariable: Variable = variableRepository.findVariable(organizationName = type.id.organization.id, superTypeName = key.list!!.type.id.superTypeName, typeName = key.list!!.type.id.name, superList = ref.asJsonObject.get("context").asLong, name = ref.asJsonObject.get("variableName").asString)
                    ?: throw CustomJsonException("{${key.id.name}: 'Unable to find referenced local field of global variable'}")
                referencedVariable.referenceCount += 1
                if (referencedVariable.id.type.multiplicity != 0L && referencedVariable.referenceCount > referencedVariable.id.type.multiplicity)
                  throw CustomJsonException("{${key.id.name}: 'Unable to reference variable due to variable's reference limit'}")
                if (!referencedVariable.active)
                  throw CustomJsonException("{${key.id.name}: 'Unable to reference variable as it is inactive'}")
                list.variables.add(referencedVariable)
                list.size += 1
              }
            }
          }
          if (list.size < list.listType.min)
            throw CustomJsonException("{${key.id.name}: 'List cannot contain less than ${list.listType.min} variables'}")
          if (list.listType.max != 0 && list.size > list.listType.max)
            throw CustomJsonException("{${key.id.name}: 'List cannot contain more than ${list.listType.max} variables'}")
          variable.values.add(Value(id = ValueId(variable = variable, key = key), list = list))
        }
        else -> {
          if (key.type.id.superTypeName == GLOBAL_TYPE) {
            val referencedVariable: Variable = variableRepository.findByTypeAndName(superList = type.id.organization.superList!!, type = key.type, name = values.get(key.id.name).asString)
                ?: throw CustomJsonException("{${key.id.name}: 'Unable to find referenced global variable'}")
            referencedVariable.referenceCount += 1
            if (referencedVariable.id.type.multiplicity != 0L && referencedVariable.referenceCount > referencedVariable.id.type.multiplicity)
              throw CustomJsonException("{${key.id.name}: 'Unable to reference variable due to variable's reference limit'}")
            if (!referencedVariable.active)
              throw CustomJsonException("{${key.id.name}: 'Unable to reference variable as it is inactive'}")
            variable.values.add(Value(id = ValueId(variable = variable, key = key), referencedVariable = referencedVariable))
          } else {
            if ((key.id.parentType.id.superTypeName == GLOBAL_TYPE && key.id.parentType.id.name == key.type.id.superTypeName)
                || (key.id.parentType.id.superTypeName != GLOBAL_TYPE && key.id.parentType.id.superTypeName == key.type.id.superTypeName)) {
              val referencedVariable: Variable = try {
                createVariable(JsonObject().apply {
                  addProperty("variableName", "")
                  add("values", values.get(key.id.name).asJsonObject.get("values").asJsonObject)
                }, variableTypePermission = keyPermission.referencedTypePermission!!, variableSuperList = variable.subList)
              } catch (exception: CustomJsonException) {
                throw CustomJsonException("{${key.id.name}: ${exception.message}}")
              }
              referencedVariable.referenceCount += 1
              variable.values.add(Value(id = ValueId(variable = variable, key = key), referencedVariable = referencedVariable))
            } else {
              val referencedVariable: Variable = variableRepository.findVariable(organizationName = type.id.organization.id, superTypeName = key.type.id.superTypeName, typeName = key.type.id.name, superList = values.get(key.id.name).asJsonObject.get("context").asLong, name = values.get(key.id.name).asJsonObject.get("variableName").asString)
                  ?: throw CustomJsonException("{${key.id.name}: 'Unable to find referenced local field of global variable'}")
              referencedVariable.referenceCount += 1
              if (referencedVariable.id.type.multiplicity != 0L && referencedVariable.referenceCount > referencedVariable.id.type.multiplicity)
                throw CustomJsonException("{${key.id.name}: 'Unable to reference variable due to variable's reference limit'}")
              if (!referencedVariable.active)
                throw CustomJsonException("{${key.id.name}: 'Unable to reference variable as it is inactive'}")
              variable.values.add(Value(id = ValueId(variable = variable, key = key), referencedVariable = referencedVariable))
            }
          }
        }
      }
    }
    // Process formula type values
    type.keys.filter { it.type.id.name == TypeConstants.FORMULA }.forEach {
      val expression: String = it.formula?.expression
          ?: throw CustomJsonException("{${it.id.name}: 'Unable to process formula'}")
      val returnTypeName: String = it.formula!!.returnType.id.name
      val leafKeyTypeAndValues: Map<String, Map<String, String>> = getLeafNameTypeValues(prefix = null, keys = mutableMapOf(), variable = variable, depth = 0)
      val injectedVariables: Array<String?> = arrayOfNulls(leafKeyTypeAndValues.size)
      val injectedClasses: Array<Class<*>?> = arrayOfNulls(leafKeyTypeAndValues.size)
      val injectedObjects: Array<Any?> = arrayOfNulls(leafKeyTypeAndValues.size)
      var index = 0
      for ((key, value) in leafKeyTypeAndValues) {
        injectedVariables[index] = key
        when (value[KeyConstants.KEY_TYPE]) {
          TypeConstants.TEXT -> {
            injectedClasses[index] = String::class.javaObjectType
            injectedObjects[index] = value[KeyConstants.VALUE]
          }
          TypeConstants.NUMBER -> {
            injectedClasses[index] = Long::class.javaObjectType
            injectedObjects[index] = value[KeyConstants.VALUE]?.toLong()
          }
          TypeConstants.DECIMAL -> {
            injectedClasses[index] = Double::class.javaObjectType
            injectedObjects[index] = value[KeyConstants.VALUE]?.toDouble()
          }
          TypeConstants.BOOLEAN -> {
            injectedClasses[index] = Boolean::class.javaObjectType
            injectedObjects[index] = value[KeyConstants.VALUE]?.toBoolean()
          }
        }
        index += 1
      }
      val evaluator = ExpressionEvaluator()
      evaluator.setParameters(injectedVariables, injectedClasses)
      when (returnTypeName) {
        TypeConstants.TEXT -> {
          evaluator.setExpressionType(String::class.javaObjectType)
          // Check expression for any compilation errors
          try {
            evaluator.cook(expression)
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.name}: 'Unable to parse formula expression'}")
          }
          // Evaluate expression and get back result
          try {
            variable.values.add(Value(id = ValueId(variable = variable, key = it), stringValue = FormulaUtils.evaluateExpression(evaluator, injectedObjects) as String))
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.name}: 'Formula expression resulted in error'}")
          }
        }
        TypeConstants.NUMBER -> {
          evaluator.setExpressionType(Long::class.javaObjectType)
          try {
            evaluator.cook(expression)
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.name}: 'Unable to parse formula expression'}")
          }
          try {
            variable.values.add(Value(id = ValueId(variable = variable, key = it), longValue = FormulaUtils.evaluateExpression(evaluator, injectedObjects) as Long))
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.name}: 'Formula expression resulted in error'}")
          }
        }
        TypeConstants.DECIMAL -> {
          evaluator.setExpressionType(Double::class.javaObjectType)
          try {
            evaluator.cook(expression)
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.name}: 'Unable to parse formula expression'}")
          }
          try {
            variable.values.add(Value(id = ValueId(variable = variable, key = it), doubleValue = FormulaUtils.evaluateExpression(evaluator, injectedObjects) as Double))
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.name}: 'Formula expression resulted in error'}")
          }
        }
        TypeConstants.BOOLEAN -> {
          evaluator.setExpressionType(Boolean::class.javaObjectType)
          try {
            evaluator.cook(expression)
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.name}: 'Unable to parse formula expression'}")
          }
          try {
            variable.values.add(Value(id = ValueId(variable = variable, key = it), booleanValue = FormulaUtils.evaluateExpression(evaluator, injectedObjects) as Boolean))
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.name}: 'Formula expression resulted in error'}")
          }
        }
      }
    }
    return try {
      // TODO: This should fail if variable is already present.
      // But that is not the case right now.
      variableRepository.save(variable)
    } catch (exception: Exception) {
      throw CustomJsonException("{variableName: 'Variable could not be created'}")
    }
  }

  @Transactional(rollbackFor = [CustomJsonException::class])
  fun updateVariable(jsonParams: JsonObject, referencedKeyVariable: Variable? = null, variableTypePermission: TypePermission? = null, variableSuperList: VariableList? = null): Variable {
    val typePermission: TypePermission = variableTypePermission
        ?: userService.superimposeUserPermissions(jsonParams = JsonObject().apply {
          addProperty("organization", jsonParams.get("organization").asString)
          addProperty("username", jsonParams.get("username").asString)
          addProperty("typeName", jsonParams.get("typeName").asString)
        })
    val type: Type = typePermission.id.type
    val superList: VariableList = variableSuperList ?: type.id.organization.superList!!
    val variable: Variable = referencedKeyVariable
        ?: variableRepository.findVariable(organizationName = type.id.organization.id, superTypeName = type.id.superTypeName, typeName = type.id.name, superList = superList.id, name = jsonParams.get("variableName").asString)
        ?: throw CustomJsonException("{variableName: 'Unable to find referenced variable'}")
    if (jsonParams.has("active?"))
      variable.active = jsonParams.get("active?").asBoolean
    val values: JsonObject = if (jsonParams.has("values")) validateUpdatedVariableValues(values = jsonParams.get("values").asJsonObject, typePermission = typePermission) else JsonObject()
    // Process non-formula type values
    variable.values.filter { it.id.key.type.id.name != TypeConstants.FORMULA }.forEach { value ->
      if (values.has(value.id.key.id.name)) {
        when (value.id.key.type.id.name) {
          TypeConstants.TEXT -> value.stringValue = values.get(value.id.key.id.name).asString
          TypeConstants.NUMBER -> value.longValue = values.get(value.id.key.id.name).asLong
          TypeConstants.DECIMAL -> value.doubleValue = values.get(value.id.key.id.name).asDouble
          TypeConstants.BOOLEAN -> value.booleanValue = values.get(value.id.key.id.name).asBoolean
          TypeConstants.FORMULA -> {/* Formulas may depend on provided values, so they will be computed separately */
          }
          TypeConstants.LIST -> {
            val listValues: JsonObject = values.get(value.id.key.id.name).asJsonObject
            if (value.list!!.listType.type.id.superTypeName == GLOBAL_TYPE) {
              if (listValues.has("add")) {
                listValues.get("add").asJsonArray.forEach {
                  val referencedVariable = variableRepository.findVariable(organizationName = type.id.organization.id, superTypeName = value.list!!.listType.type.id.superTypeName, typeName = value.list!!.listType.type.id.name, superList = type.id.organization.superList!!.id, name = it.asString)
                      ?: throw CustomJsonException("{${value.id.key.id.name}: {add: 'Unable to insert ${it.asString} referenced in list'}}")
                  if (!value.list!!.variables.contains(referencedVariable)) {
                    referencedVariable.referenceCount += 1
                    if (referencedVariable.id.type.multiplicity != 0L && referencedVariable.referenceCount > referencedVariable.id.type.multiplicity)
                      throw CustomJsonException("{${value.id.key.id.name}: 'Unable to reference variable due to variable's reference limit'}")
                    if (!referencedVariable.active)
                      throw CustomJsonException("{${value.id.key.id.name}: 'Unable to reference variable as it is inactive'}")
                    value.list!!.variables.add(referencedVariable)
                    value.list!!.size += 1
                  } else throw CustomJsonException("{${value.id.key.id.name}: {add: '${it.asString} is already present in list'}}")
                }
              }
              if (listValues.has("remove")) {
                listValues.get("remove").asJsonArray.forEach {
                  val referencedVariable = variableRepository.findVariable(organizationName = type.id.organization.id, superTypeName = value.list!!.listType.type.id.superTypeName, typeName = value.list!!.listType.type.id.name, superList = type.id.organization.superList!!.id, name = it.asString)
                      ?: throw CustomJsonException("{${value.id.key.id.name}: {remove: 'Unable to remove ${it.asString} referenced in list'}}")
                  if (value.list!!.variables.contains(referencedVariable)) {
                    referencedVariable.referenceCount -= 1
                    value.list!!.variables.remove(referencedVariable)
                    value.list!!.size -= 1
                    variableRepository.save(referencedVariable)
                  } else throw CustomJsonException("{${value.id.key.id.name}: {remove: '${it.asString} is not present in list'}}")
                }
              }
            } else {
              if ((value.id.key.id.parentType.id.superTypeName == GLOBAL_TYPE && value.id.key.id.parentType.id.name == value.id.key.list!!.type.id.superTypeName)
                  || (value.id.key.id.parentType.id.superTypeName != GLOBAL_TYPE && value.id.key.id.parentType.id.superTypeName == value.id.key.list!!.type.id.superTypeName)) {
                if (listValues.has("add")) {
                  listValues.get("add").asJsonArray.forEach {
                    val referencedVariable = try {
                      createVariable(jsonParams = it.asJsonObject, variableTypePermission = typePermission.keyPermissions.single { keyPermission -> keyPermission.id.key == value.id.key }.referencedTypePermission!!, variableSuperList = value.list!!)
                    } catch (exception: CustomJsonException) {
                      throw CustomJsonException("{${value.id.key.id.name}: {${it.asJsonObject.get("variableName").asString}: {add: 'Unable to add variable to list'}}}")
                    }
                    if (!value.list!!.variables.contains(referencedVariable)) {
                      referencedVariable.referenceCount += 1
                      if (referencedVariable.id.type.multiplicity != 0L && referencedVariable.referenceCount > referencedVariable.id.type.multiplicity)
                        throw CustomJsonException("{${value.id.key.id.name}: 'Unable to reference variable due to variable's reference limit'}")
                      value.list!!.variables.add(referencedVariable)
                      value.list!!.size += 1
                    } else throw CustomJsonException("{${value.id.key.id.name}: {add: '${it.asJsonObject.get("variableName").asString} is already present in list'}}")
                  }
                }
                if (listValues.has("remove")) {
                  listValues.get("remove").asJsonArray.forEach {
                    val referencedVariable = variableRepository.findVariable(organizationName = type.id.organization.id, superTypeName = value.list!!.listType.type.id.superTypeName, typeName = value.list!!.listType.type.id.name, superList = value.list!!.id, name = it.asString)
                        ?: throw CustomJsonException("{${value.id.key.id.name}: {remove: 'Unable to find ${it.asString} referenced in list'}}")
                    if (value.list!!.variables.contains(referencedVariable)) {
                      referencedVariable.referenceCount -= 1
                      value.list!!.variables.remove(referencedVariable)
                      value.list!!.size -= 1
                      if (referencedVariable.referenceCount == 0L) {
                        referencedVariable.id.type.variableCount -= 1
                        variableRepository.delete(referencedVariable)
                      } else
                        variableRepository.save(referencedVariable)
                    } else throw CustomJsonException("{${value.id.key.id.name}: {remove: '${it.asString} is not present in list'}}")
                  }
                }
                if (listValues.has("update")) {
                  listValues.get("update").asJsonArray.forEach {
                    val variableToUpdate: Variable = variableRepository.findVariable(organizationName = type.id.organization.id, superTypeName = value.list!!.listType.type.id.superTypeName, typeName = value.list!!.listType.type.id.name, superList = value.list!!.id, name = it.asJsonObject.get("variableName").asString)
                        ?: throw CustomJsonException("{${value.id.key.id.name}: {update: 'Unable to find referenced variable in list'}}")
                    value.list!!.variables.remove(variableToUpdate)
                    val updatedVariable: Variable = try {
                      updateVariable(jsonParams = it.asJsonObject, variableTypePermission = typePermission.keyPermissions.single { keyPermission -> keyPermission.id.key.id.name == value.id.key.id.name }.referencedTypePermission!!, variableSuperList = value.list!!)
                    } catch (exception: CustomJsonException) {
                      throw CustomJsonException("{${value.id.key.id.name}: {update: ${exception.message}}}")
                    }
                    value.list!!.variables.add(updatedVariable)
                  }
                }
              } else {
                if (listValues.has("add")) {
                  listValues.get("add").asJsonArray.forEach {
                    val referencedVariable = variableRepository.findVariable(organizationName = type.id.organization.id, superTypeName = value.list!!.listType.type.id.superTypeName, typeName = value.list!!.listType.type.id.name, superList = it.asJsonObject.get("context").asLong, name = it.asJsonObject.get("variableName").asString)
                        ?: throw CustomJsonException("{${value.id.key.id.name}: {add: 'Unable to insert ${it.asJsonObject.get("variableName").asString} referenced in list'}}")
                    if (!value.list!!.variables.contains(referencedVariable)) {
                      referencedVariable.referenceCount += 1
                      if (referencedVariable.id.type.multiplicity != 0L && referencedVariable.referenceCount > referencedVariable.id.type.multiplicity)
                        throw CustomJsonException("{${value.id.key.id.name}: 'Unable to reference variable due to variable's reference limit'}")
                      if (!referencedVariable.active)
                        throw CustomJsonException("{${value.id.key.id.name}: 'Unable to reference variable as it is inactive'}")
                      value.list!!.variables.add(referencedVariable)
                      value.list!!.size += 1
                    } else throw CustomJsonException("{${value.id.key.id.name}: {add: '${it.asJsonObject.get("variableName").asString} is already present in list'}}")
                  }
                }
                if (listValues.has("remove")) {
                  listValues.get("remove").asJsonArray.forEach {
                    val referencedVariable = variableRepository.findVariable(organizationName = type.id.organization.id, superTypeName = value.list!!.listType.type.id.superTypeName, typeName = value.list!!.listType.type.id.name, superList = it.asJsonObject.get("context").asLong, name = it.asJsonObject.get("variableName").asString)
                        ?: throw CustomJsonException("{${value.id.key.id.name}: {remove: 'Unable to remove ${it.asJsonObject.get("variableName").asString} referenced in list'}}")
                    if (value.list!!.variables.contains(referencedVariable)) {
                      referencedVariable.referenceCount -= 1
                      value.list!!.variables.remove(referencedVariable)
                      value.list!!.size -= 1
                      variableRepository.save(referencedVariable)
                    } else throw CustomJsonException("{${value.id.key.id.name}: {remove: '${it.asJsonObject.get("variableName").asString} is not present in list'}}")
                  }
                }
              }
            }
            if (value.list!!.size < value.list!!.listType.min)
              throw CustomJsonException("{${value.id.key.id.name}: 'List cannot contain less than ${value.list!!.listType.min} variables'}")
            if (value.list!!.listType.max != 0 && value.list!!.size > value.list!!.listType.max)
              throw CustomJsonException("{${value.id.key.id.name}: 'List cannot contain more than ${value.list!!.listType.max} variables'}")
          }
          else -> {
            if (value.id.key.type.id.superTypeName == GLOBAL_TYPE) {
              value.referencedVariable!!.referenceCount -= 1
              variableRepository.save(value.referencedVariable!!)
              val referencedVariable = variableRepository.findVariable(organizationName = type.id.organization.id, superTypeName = value.id.key.type.id.superTypeName, typeName = value.id.key.type.id.name, superList = type.id.organization.superList!!.id, name = values.get(value.id.key.id.name).asString)
                  ?: throw CustomJsonException("{${value.id.key.id.name}: 'Unable to find referenced variable ${values.get(value.id.key.id.name).asString}'}")
              referencedVariable.referenceCount += 1
              if (referencedVariable.id.type.multiplicity != 0L && referencedVariable.referenceCount > referencedVariable.id.type.multiplicity)
                throw CustomJsonException("{${value.id.key.id.name}: 'Unable to reference variable due to variable's reference limit'}")
              if (!referencedVariable.active)
                throw CustomJsonException("{${value.id.key.id.name}: 'Unable to reference variable as it is inactive'}")
              value.referencedVariable = referencedVariable
            } else {
              if ((value.id.key.id.parentType.id.superTypeName == GLOBAL_TYPE && value.id.key.id.parentType.id.name == value.id.key.type.id.superTypeName)
                  || (value.id.key.id.parentType.id.superTypeName != GLOBAL_TYPE && value.id.key.id.parentType.id.superTypeName == value.id.key.type.id.superTypeName)) {
                value.referencedVariable = try {
                  updateVariable(jsonParams = values.get(value.id.key.id.name).asJsonObject, referencedKeyVariable = value.referencedVariable!!, variableTypePermission = typePermission.keyPermissions.single { keyPermission -> keyPermission.id.key.id.name == value.id.key.id.name }.referencedTypePermission!!, variableSuperList = value.referencedVariable!!.id.superList)
                } catch (exception: CustomJsonException) {
                  throw CustomJsonException("{${value.id.key.id.name}: ${exception.message}}")
                }
              } else {
                value.referencedVariable!!.referenceCount -= 1
                variableRepository.save(value.referencedVariable!!)
                val referencedVariable = variableRepository.findVariable(organizationName = type.id.organization.id, superTypeName = value.id.key.type.id.superTypeName, typeName = value.id.key.type.id.name, superList = values.get(value.id.key.id.name).asJsonObject.get("context").asLong, name = values.get(value.id.key.id.name).asJsonObject.get("variableName").asString)
                    ?: throw CustomJsonException("{${value.id.key.id.name}: 'Unable to find referenced variable ${values.get(value.id.key.id.name).asJsonObject.get("variableName").asString}'}")
                referencedVariable.referenceCount += 1
                if (referencedVariable.id.type.multiplicity != 0L && referencedVariable.referenceCount > referencedVariable.id.type.multiplicity)
                  throw CustomJsonException("{${value.id.key.id.name}: 'Unable to reference variable due to variable's reference limit'}")
                if (!referencedVariable.active)
                  throw CustomJsonException("{${value.id.key.id.name}: 'Unable to reference variable as it is inactive'}")
                value.referencedVariable = referencedVariable
              }
            }
          }
        }
      }
    }
    // Process formula type values
    // Recompute formula values
    // TODO: To be optimized in future so that formula is computed only upon change in dependent fields
    variable.values.filter { it.id.key.type.id.name == TypeConstants.FORMULA }.forEach {
      val expression: String = it.id.key.formula!!.expression
      val returnTypeName: String = it.id.key.formula!!.returnType.id.name
      val leafKeyTypeAndValues: Map<String, Map<String, String>> = getLeafNameTypeValues(prefix = null, keys = mutableMapOf(), variable = variable, depth = 0)
      val injectedVariables: Array<String?> = arrayOfNulls(leafKeyTypeAndValues.size)
      val injectedClasses: Array<Class<*>?> = arrayOfNulls(leafKeyTypeAndValues.size)
      val injectedObjects: Array<Any?> = arrayOfNulls(leafKeyTypeAndValues.size)
      var index = 0
      for ((key, value) in leafKeyTypeAndValues) {
        injectedVariables[index] = key
        when (value[KeyConstants.KEY_TYPE]) {
          TypeConstants.TEXT -> {
            injectedClasses[index] = String::class.javaObjectType
            injectedObjects[index] = value[KeyConstants.VALUE]
          }
          TypeConstants.NUMBER -> {
            injectedClasses[index] = Long::class.javaObjectType
            injectedObjects[index] = value[KeyConstants.VALUE]?.toLong()
          }
          TypeConstants.DECIMAL -> {
            injectedClasses[index] = Double::class.javaObjectType
            injectedObjects[index] = value[KeyConstants.VALUE]?.toDouble()
          }
          TypeConstants.BOOLEAN -> {
            injectedClasses[index] = Boolean::class.javaObjectType
            injectedObjects[index] = value[KeyConstants.VALUE]?.toBoolean()
          }
        }
        index += 1
      }
      val evaluator = ExpressionEvaluator()
      evaluator.setParameters(injectedVariables, injectedClasses)
      when (returnTypeName) {
        TypeConstants.TEXT -> {
          evaluator.setExpressionType(String::class.javaObjectType)
          // Check expression for any compilation errors
          try {
            evaluator.cook(expression)
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.key.id.name}: 'Unable to parse formula expression'}")
          }
          // Evaluate expression and get back result
          try {
            it.stringValue = FormulaUtils.evaluateExpression(evaluator, injectedObjects) as String
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.key.id.name}: 'Formula expression resulted in error'}")
          }
        }
        TypeConstants.NUMBER -> {
          evaluator.setExpressionType(Long::class.javaObjectType)
          try {
            evaluator.cook(expression)
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.key.id.name}: 'Unable to parse formula expression'}")
          }
          try {
            it.longValue = FormulaUtils.evaluateExpression(evaluator, injectedObjects) as Long
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.key.id.name}: 'Formula expression resulted in error'}")
          }
        }
        TypeConstants.DECIMAL -> {
          evaluator.setExpressionType(Double::class.javaObjectType)
          try {
            evaluator.cook(expression)
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.key.id.name}: 'Unable to parse formula expression'}")
          }
          try {
            it.doubleValue = FormulaUtils.evaluateExpression(evaluator, injectedObjects) as Double
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.key.id.name}: 'Formula expression resulted in error'}")
          }
        }
        TypeConstants.BOOLEAN -> {
          evaluator.setExpressionType(Boolean::class.javaObjectType)
          try {
            evaluator.cook(expression)
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.key.id.name}: 'Unable to parse formula expression'}")
          }
          try {
            it.booleanValue = FormulaUtils.evaluateExpression(evaluator, injectedObjects) as Boolean
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.key.id.name}: 'Formula expression resulted in error'}")
          }
        }
      }
    }
    if (jsonParams.has("updatedVariableName?"))
      variable.id.name = jsonParams.get("updatedVariableName?").asString
    try {
      variableRepository.save(variable)
    } catch (exception: Exception) {
      throw CustomJsonException("{variableName: 'Variable could not be updated'}")
    }
    return variable
  }
}
