/* 
 * Copyright (C) 2020 Pibity Infotech Private Limited - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 * THIS IS UNPUBLISHED PROPRIETARY CODE OF PIBITY INFOTECH PRIVATE LIMITED
 * The copyright notice above does not evidence any actual or intended publication of such source code.
 */

package com.pibity.erp.services

import com.google.gson.JsonArray
import com.google.gson.JsonObject
import com.pibity.erp.commons.constants.GLOBAL_TYPE
import com.pibity.erp.commons.constants.TypeConstants
import com.pibity.erp.commons.exceptions.CustomJsonException
import com.pibity.erp.commons.utils.*
import com.pibity.erp.entities.*
import com.pibity.erp.entities.embeddables.ValueId
import com.pibity.erp.entities.embeddables.VariableId
import com.pibity.erp.repositories.ValueRepository
import com.pibity.erp.repositories.VariableListRepository
import com.pibity.erp.repositories.VariableRepository
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class VariableService(
    val variableRepository: VariableRepository,
    val variableListRepository: VariableListRepository,
    val userService: UserService,
    val valueRepository: ValueRepository
) {

  @Transactional(rollbackFor = [CustomJsonException::class])
  fun createVariable(jsonParams: JsonObject, variableSuperList: VariableList? = null, variableSubList: VariableList? = null, variableTypePermission: TypePermission? = null): Variable {
    println("-----CREATE--VARIABLE-----")
    println(jsonParams)
    val typePermission: TypePermission = variableTypePermission
        ?: userService.superimposeUserPermissions(jsonParams = JsonObject().apply {
          addProperty("organization", jsonParams.get("organization").asString)
          addProperty("username", jsonParams.get("username").asString)
          addProperty("typeName", jsonParams.get("typeName").asString)
        })
    if (typePermission.id.type.id.superTypeName == GLOBAL_TYPE && !typePermission.creatable)
      throw CustomJsonException("{error: 'Unauthorized Access'}")
    val variableName: String = jsonParams.get("variableName").asString
    val type: Type = typePermission.id.type
    val superList: VariableList = variableSuperList ?: type.id.organization.superList!!
    val values: JsonObject = validateVariableValues(values = jsonParams.get("values").asJsonObject, typePermission = typePermission)
    val variable = Variable(id = VariableId(superList = superList, type = type, name = if (type.id.superTypeName == GLOBAL_TYPE && type.autoAssignId) (type.autoIncrementId + 1).toString() else variableName), autoGeneratedId = type.autoIncrementId + 1, subList = variableSubList
        ?: variableListRepository.save(VariableList(listType = type.id.organization.superList!!.listType)))
    variable.id.type.autoIncrementId += 1
    variable.id.type.variableCount += 1
    // Process non-formula type values
    typePermission.keyPermissions.filter { it.id.key.type.id.name != TypeConstants.FORMULA }.forEach { keyPermission ->
      val key = keyPermission.id.key
      when (key.type.id.name) {
        TypeConstants.TEXT -> variable.values.add(Value(id = ValueId(variable = variable, key = key), stringValue = values.get(key.id.name).asString))
        TypeConstants.NUMBER -> variable.values.add(Value(id = ValueId(variable = variable, key = key), longValue = values.get(key.id.name).asLong))
        TypeConstants.DECIMAL -> variable.values.add(Value(id = ValueId(variable = variable, key = key), doubleValue = values.get(key.id.name).asDouble))
        TypeConstants.BOOLEAN -> variable.values.add(Value(id = ValueId(variable = variable, key = key), booleanValue = values.get(key.id.name).asBoolean))
        TypeConstants.LIST -> {
          val jsonArray: JsonArray = values.get(key.id.name).asJsonArray
          val list: VariableList = try {
            variableListRepository.save(VariableList(listType = key.list!!))
          } catch (exception: Exception) {
            throw CustomJsonException("{${key.id.name}: 'Unable to create List'}")
          }
          for (ref in jsonArray.iterator()) {
            if (key.list!!.type.id.superTypeName == GLOBAL_TYPE) {
              val referencedVariable: Variable = variableRepository.findByTypeAndName(superList = type.id.organization.superList!!, type = key.list!!.type, name = ref.asString)
                  ?: throw CustomJsonException("{${key.id.name}: 'Unable to find referenced global variable'}")
              referencedVariable.referenceCount += 1
              if (referencedVariable.id.type.multiplicity != 0L && referencedVariable.referenceCount > referencedVariable.id.type.multiplicity)
                throw CustomJsonException("{${key.id.name}: 'Unable to reference variable due to variable's reference limit'}")
              if (!referencedVariable.active)
                throw CustomJsonException("{${key.id.name}: 'Unable to reference variable as it is inactive'}")
              list.variables.add(referencedVariable)
              list.size += 1
            } else {
              if ((key.id.parentType.id.superTypeName == GLOBAL_TYPE && key.id.parentType.id.name == key.list!!.type.id.superTypeName)
                  || (key.id.parentType.id.superTypeName != GLOBAL_TYPE && key.id.parentType.id.superTypeName == key.list!!.type.id.superTypeName)) {
                val referencedVariable: Variable = try {
                  createVariable(JsonObject().apply {
                    addProperty("variableName", ref.asJsonObject.get("variableName").asString)
                    add("values", ref.asJsonObject.get("values").asJsonObject)
                  }, variableTypePermission = keyPermission.referencedTypePermission!!,
                      variableSuperList = list,
                      variableSubList = variableListRepository.save(VariableList(listType = list.listType)))
                } catch (exception: CustomJsonException) {
                  throw CustomJsonException("{${key.id.name}: ${exception.message}}")
                }
                referencedVariable.referenceCount += 1
                list.variables.add(referencedVariable)
                list.size += 1
              } else {
                val referencedVariable: Variable = variableRepository.findVariable(organizationName = type.id.organization.id, superTypeName = key.list!!.type.id.superTypeName, typeName = key.list!!.type.id.name, superList = ref.asJsonObject.get("context").asLong, name = ref.asJsonObject.get("variableName").asString)
                    ?: throw CustomJsonException("{${key.id.name}: 'Unable to find referenced local field of global variable'}")
                referencedVariable.referenceCount += 1
                if (referencedVariable.id.type.multiplicity != 0L && referencedVariable.referenceCount > referencedVariable.id.type.multiplicity)
                  throw CustomJsonException("{${key.id.name}: 'Unable to reference variable due to variable's reference limit'}")
                if (!referencedVariable.active)
                  throw CustomJsonException("{${key.id.name}: 'Unable to reference variable as it is inactive'}")
                list.variables.add(referencedVariable)
                list.size += 1
              }
            }
          }
          if (list.size < list.listType.min)
            throw CustomJsonException("{${key.id.name}: 'List cannot contain less than ${list.listType.min} variables'}")
          if (list.listType.max != 0 && list.size > list.listType.max)
            throw CustomJsonException("{${key.id.name}: 'List cannot contain more than ${list.listType.max} variables'}")
          variable.values.add(Value(id = ValueId(variable = variable, key = key), list = list))
        }
        else -> {
          if (key.type.id.superTypeName == GLOBAL_TYPE) {
            val referencedVariable: Variable = variableRepository.findByTypeAndName(superList = type.id.organization.superList!!, type = key.type, name = values.get(key.id.name).asString)
                ?: throw CustomJsonException("{${key.id.name}: 'Unable to find referenced global variable'}")
            referencedVariable.referenceCount += 1
            if (referencedVariable.id.type.multiplicity != 0L && referencedVariable.referenceCount > referencedVariable.id.type.multiplicity)
              throw CustomJsonException("{${key.id.name}: 'Unable to reference variable due to variable's reference limit'}")
            if (!referencedVariable.active)
              throw CustomJsonException("{${key.id.name}: 'Unable to reference variable as it is inactive'}")
            variable.values.add(Value(id = ValueId(variable = variable, key = key), referencedVariable = referencedVariable))
          } else {
            if ((key.id.parentType.id.superTypeName == GLOBAL_TYPE && key.id.parentType.id.name == key.type.id.superTypeName)
                || (key.id.parentType.id.superTypeName != GLOBAL_TYPE && key.id.parentType.id.superTypeName == key.type.id.superTypeName)) {
              val referencedVariable: Variable = try {
                createVariable(JsonObject().apply {
                  addProperty("variableName", "")
                  add("values", values.get(key.id.name).asJsonObject.get("values").asJsonObject)
                }, variableTypePermission = keyPermission.referencedTypePermission!!, variableSuperList = variable.subList, variableSubList = variable.subList)
              } catch (exception: CustomJsonException) {
                throw CustomJsonException("{${key.id.name}: ${exception.message}}")
              }
              referencedVariable.referenceCount += 1
              variable.values.add(Value(id = ValueId(variable = variable, key = key), referencedVariable = referencedVariable))
            } else {
              val referencedVariable: Variable = variableRepository.findVariable(organizationName = type.id.organization.id, superTypeName = key.type.id.superTypeName, typeName = key.type.id.name, superList = values.get(key.id.name).asJsonObject.get("context").asLong, name = values.get(key.id.name).asJsonObject.get("variableName").asString)
                  ?: throw CustomJsonException("{${key.id.name}: 'Unable to find referenced local field of global variable'}")
              referencedVariable.referenceCount += 1
              if (referencedVariable.id.type.multiplicity != 0L && referencedVariable.referenceCount > referencedVariable.id.type.multiplicity)
                throw CustomJsonException("{${key.id.name}: 'Unable to reference variable due to variable's reference limit'}")
              if (!referencedVariable.active)
                throw CustomJsonException("{${key.id.name}: 'Unable to reference variable as it is inactive'}")
              variable.values.add(Value(id = ValueId(variable = variable, key = key), referencedVariable = referencedVariable))
            }
          }
        }
      }
    }
    val createdVariable: Variable = try {
      variableRepository.save(variable)
    } catch (exception: Exception) {
      throw CustomJsonException("{variableName: 'Variable could not be created'}")
    }
    typePermission.keyPermissions.filter { it.id.key.type.id.name == TypeConstants.FORMULA }.forEach { keyPermission ->
      val key: Key = keyPermission.id.key
      val valueDependencies: MutableSet<Value> = mutableSetOf()
      val value: Value = when (key.formula!!.returnType.id.name) {
        TypeConstants.TEXT -> Value(id = ValueId(variable = createdVariable, key = key),
            stringValue = validateOrEvaluateExpression(jsonParams = gson.fromJson(key.formula!!.expression, JsonObject::class.java).apply { addProperty("expectedReturnType", key.formula!!.returnType.id.name) },
                symbols = getSymbolValuesAndUpdateDependencies(variable = createdVariable, symbolPaths = gson.fromJson(key.formula!!.symbolPaths, JsonArray::class.java).map { it.asString }.toMutableSet(), valueDependencies = valueDependencies), mode = "evaluate") as String)
        TypeConstants.NUMBER -> Value(id = ValueId(variable = createdVariable, key = key),
            longValue = validateOrEvaluateExpression(jsonParams = gson.fromJson(key.formula!!.expression, JsonObject::class.java).apply { addProperty("expectedReturnType", key.formula!!.returnType.id.name) },
                symbols = getSymbolValuesAndUpdateDependencies(variable = createdVariable, symbolPaths = gson.fromJson(key.formula!!.symbolPaths, JsonArray::class.java).map { it.asString }.toMutableSet(), valueDependencies = valueDependencies), mode = "evaluate") as Long)
        TypeConstants.DECIMAL -> Value(id = ValueId(variable = createdVariable, key = key),
            doubleValue = validateOrEvaluateExpression(jsonParams = gson.fromJson(key.formula!!.expression, JsonObject::class.java).apply { addProperty("expectedReturnType", key.formula!!.returnType.id.name) },
                symbols = getSymbolValuesAndUpdateDependencies(variable = createdVariable, symbolPaths = gson.fromJson(key.formula!!.symbolPaths, JsonArray::class.java).map { it.asString }.toMutableSet(), valueDependencies = valueDependencies), mode = "evaluate") as Double)
        TypeConstants.BOOLEAN -> Value(id = ValueId(variable = createdVariable, key = key),
            booleanValue = validateOrEvaluateExpression(jsonParams = gson.fromJson(key.formula!!.expression, JsonObject::class.java).apply { addProperty("expectedReturnType", key.formula!!.returnType.id.name) },
                symbols = getSymbolValuesAndUpdateDependencies(variable = createdVariable, symbolPaths = gson.fromJson(key.formula!!.symbolPaths, JsonArray::class.java).map { it.asString }.toMutableSet(), valueDependencies = valueDependencies), mode = "evaluate") as Boolean)
        else -> throw CustomJsonException("{${key.id.name}: 'Unable to compute formula value'}")
      }
      value.valueDependencies.addAll(valueDependencies)
      createdVariable.values.add(value)
    }
    return try {
      // TODO: This should fail if variable is already present.
      // But that is not the case right now.
      variableRepository.save(createdVariable)
    } catch (exception: Exception) {
      throw CustomJsonException("{variableName: 'Variable could not be created'}")
    }
  }

  @Transactional(rollbackFor = [CustomJsonException::class])
  fun updateVariable(jsonParams: JsonObject, referencedKeyVariable: Variable? = null, variableTypePermission: TypePermission? = null, variableSuperList: VariableList? = null): Pair<Variable, Map<Value, MutableSet<Value>>> {
    val typePermission: TypePermission = variableTypePermission
        ?: userService.superimposeUserPermissions(jsonParams = JsonObject().apply {
          addProperty("organization", jsonParams.get("organization").asString)
          addProperty("username", jsonParams.get("username").asString)
          addProperty("typeName", jsonParams.get("typeName").asString)
        })
    val type: Type = typePermission.id.type
    val superList: VariableList = variableSuperList ?: type.id.organization.superList!!
    val variable: Variable = referencedKeyVariable
        ?: variableRepository.findVariable(organizationName = type.id.organization.id, superTypeName = type.id.superTypeName, typeName = type.id.name, superList = superList.id, name = jsonParams.get("variableName").asString)
        ?: throw CustomJsonException("{variableName: 'Unable to find referenced variable'}")
    if (jsonParams.has("active?"))
      variable.active = jsonParams.get("active?").asBoolean
    val values: JsonObject = if (jsonParams.has("values")) validateUpdatedVariableValues(values = jsonParams.get("values").asJsonObject, typePermission = typePermission) else JsonObject()
    val dependentFormulaValues: MutableMap<Value, MutableSet<Value>> = mutableMapOf()
    // Process non-formula type values
    variable.values.filter { it.id.key.type.id.name != TypeConstants.FORMULA }.forEach { value ->
      if (values.has(value.id.key.id.name)) {
        when (value.id.key.type.id.name) {
          TypeConstants.TEXT -> {
            if (value.stringValue != values.get(value.id.key.id.name).asString) {
              value.stringValue = values.get(value.id.key.id.name).asString
              if (value.id.key.isDependency) {
                value.dependentValues.forEach {
                  if (!dependentFormulaValues.containsKey(it))
                    dependentFormulaValues[it] = mutableSetOf(value)
                  else
                    dependentFormulaValues[it]!!.add(value)
                }
              }
            }
          }
          TypeConstants.NUMBER -> {
            if (value.longValue != values.get(value.id.key.id.name).asLong) {
              value.longValue = values.get(value.id.key.id.name).asLong
              if (value.id.key.isDependency) {
                value.dependentValues.forEach {
                  if (!dependentFormulaValues.containsKey(it))
                    dependentFormulaValues[it] = mutableSetOf(value)
                  else
                    dependentFormulaValues[it]!!.add(value)
                }
              }
            }
          }
          TypeConstants.DECIMAL -> {
            if (value.doubleValue != values.get(value.id.key.id.name).asDouble) {
              value.doubleValue = values.get(value.id.key.id.name).asDouble
              if (value.id.key.isDependency) {
                value.dependentValues.forEach {
                  if (!dependentFormulaValues.containsKey(it))
                    dependentFormulaValues[it] = mutableSetOf(value)
                  else
                    dependentFormulaValues[it]!!.add(value)
                }
              }
            }
          }
          TypeConstants.BOOLEAN -> {
            if (value.booleanValue != values.get(value.id.key.id.name).asBoolean) {
              value.booleanValue = values.get(value.id.key.id.name).asBoolean
              if (value.id.key.isDependency) {
                value.dependentValues.forEach {
                  if (!dependentFormulaValues.containsKey(it))
                    dependentFormulaValues[it] = mutableSetOf(value)
                  else
                    dependentFormulaValues[it]!!.add(value)
                }
              }
            }
          }
          TypeConstants.FORMULA -> {/* Formulas may depend on provided values, so they will be computed separately */
          }
          TypeConstants.LIST -> {
            val listValues: JsonObject = values.get(value.id.key.id.name).asJsonObject
            if (value.list!!.listType.type.id.superTypeName == GLOBAL_TYPE) {
              if (listValues.has("add")) {
                listValues.get("add").asJsonArray.forEach {
                  val referencedVariable = variableRepository.findVariable(organizationName = type.id.organization.id, superTypeName = value.list!!.listType.type.id.superTypeName, typeName = value.list!!.listType.type.id.name, superList = type.id.organization.superList!!.id, name = it.asString)
                      ?: throw CustomJsonException("{${value.id.key.id.name}: {add: 'Unable to insert ${it.asString} referenced in list'}}")
                  if (!value.list!!.variables.contains(referencedVariable)) {
                    referencedVariable.referenceCount += 1
                    if (referencedVariable.id.type.multiplicity != 0L && referencedVariable.referenceCount > referencedVariable.id.type.multiplicity)
                      throw CustomJsonException("{${value.id.key.id.name}: 'Unable to reference variable due to variable's reference limit'}")
                    if (!referencedVariable.active)
                      throw CustomJsonException("{${value.id.key.id.name}: 'Unable to reference variable as it is inactive'}")
                    value.list!!.variables.add(referencedVariable)
                    value.list!!.size += 1
                  } else throw CustomJsonException("{${value.id.key.id.name}: {add: '${it.asString} is already present in list'}}")
                }
              }
              if (listValues.has("remove")) {
                listValues.get("remove").asJsonArray.forEach {
                  val referencedVariable = variableRepository.findVariable(organizationName = type.id.organization.id, superTypeName = value.list!!.listType.type.id.superTypeName, typeName = value.list!!.listType.type.id.name, superList = type.id.organization.superList!!.id, name = it.asString)
                      ?: throw CustomJsonException("{${value.id.key.id.name}: {remove: 'Unable to remove ${it.asString} referenced in list'}}")
                  if (value.list!!.variables.contains(referencedVariable)) {
                    referencedVariable.referenceCount -= 1
                    value.list!!.variables.remove(referencedVariable)
                    value.list!!.size -= 1
                    variableRepository.save(referencedVariable)
                  } else throw CustomJsonException("{${value.id.key.id.name}: {remove: '${it.asString} is not present in list'}}")
                }
              }
            } else {
              if ((value.id.key.id.parentType.id.superTypeName == GLOBAL_TYPE && value.id.key.id.parentType.id.name == value.id.key.list!!.type.id.superTypeName)
                  || (value.id.key.id.parentType.id.superTypeName != GLOBAL_TYPE && value.id.key.id.parentType.id.superTypeName == value.id.key.list!!.type.id.superTypeName)) {
                if (listValues.has("add")) {
                  listValues.get("add").asJsonArray.forEach {
                    val referencedVariable = try {
                      createVariable(jsonParams = it.asJsonObject, variableTypePermission = typePermission.keyPermissions.single { keyPermission -> keyPermission.id.key == value.id.key }.referencedTypePermission!!, variableSuperList = value.list!!, variableSubList = variableListRepository.save(VariableList(listType = value.list!!.listType)))
                    } catch (exception: CustomJsonException) {
                      throw CustomJsonException("{${value.id.key.id.name}: {${it.asJsonObject.get("variableName").asString}: {add: 'Unable to add variable to list'}}}")
                    }
                    if (!value.list!!.variables.contains(referencedVariable)) {
                      referencedVariable.referenceCount += 1
                      if (referencedVariable.id.type.multiplicity != 0L && referencedVariable.referenceCount > referencedVariable.id.type.multiplicity)
                        throw CustomJsonException("{${value.id.key.id.name}: 'Unable to reference variable due to variable's reference limit'}")
                      value.list!!.variables.add(referencedVariable)
                      value.list!!.size += 1
                    } else throw CustomJsonException("{${value.id.key.id.name}: {add: '${it.asJsonObject.get("variableName").asString} is already present in list'}}")
                  }
                }
                if (listValues.has("remove")) {
                  listValues.get("remove").asJsonArray.forEach {
                    val referencedVariable = variableRepository.findVariable(organizationName = type.id.organization.id, superTypeName = value.list!!.listType.type.id.superTypeName, typeName = value.list!!.listType.type.id.name, superList = value.list!!.id, name = it.asString)
                        ?: throw CustomJsonException("{${value.id.key.id.name}: {remove: 'Unable to find ${it.asString} referenced in list'}}")
                    if (value.list!!.variables.contains(referencedVariable)) {
                      referencedVariable.referenceCount -= 1
                      value.list!!.variables.remove(referencedVariable)
                      value.list!!.size -= 1
                      if (referencedVariable.referenceCount == 0L) {
                        referencedVariable.id.type.variableCount -= 1
                        variableRepository.delete(referencedVariable)
                      } else
                        variableRepository.save(referencedVariable)
                    } else throw CustomJsonException("{${value.id.key.id.name}: {remove: '${it.asString} is not present in list'}}")
                  }
                }
                if (listValues.has("update")) {
                  listValues.get("update").asJsonArray.forEach {
                    val variableToUpdate: Variable = variableRepository.findVariable(organizationName = type.id.organization.id, superTypeName = value.list!!.listType.type.id.superTypeName, typeName = value.list!!.listType.type.id.name, superList = value.list!!.id, name = it.asJsonObject.get("variableName").asString)
                        ?: throw CustomJsonException("{${value.id.key.id.name}: {update: 'Unable to find referenced variable in list'}}")
                    value.list!!.variables.remove(variableToUpdate)
                    val updatedVariable: Variable = try {
                      val (subVariable, subDependentFormulaValues) = updateVariable(jsonParams = it.asJsonObject, variableTypePermission = typePermission.keyPermissions.single { keyPermission -> keyPermission.id.key.id.name == value.id.key.id.name }.referencedTypePermission!!, variableSuperList = value.list!!)
                      subDependentFormulaValues.forEach { (k, v) ->
                        if (!dependentFormulaValues.containsKey(k))
                          dependentFormulaValues[k] = v
                        else
                          dependentFormulaValues[k]!!.addAll(v)
                      }
                      subVariable
                    } catch (exception: CustomJsonException) {
                      throw CustomJsonException("{${value.id.key.id.name}: {update: ${exception.message}}}")
                    }
                    value.list!!.variables.add(updatedVariable)
                  }
                }
              } else {
                if (listValues.has("add")) {
                  listValues.get("add").asJsonArray.forEach {
                    val referencedVariable = variableRepository.findVariable(organizationName = type.id.organization.id, superTypeName = value.list!!.listType.type.id.superTypeName, typeName = value.list!!.listType.type.id.name, superList = it.asJsonObject.get("context").asLong, name = it.asJsonObject.get("variableName").asString)
                        ?: throw CustomJsonException("{${value.id.key.id.name}: {add: 'Unable to insert ${it.asJsonObject.get("variableName").asString} referenced in list'}}")
                    if (!value.list!!.variables.contains(referencedVariable)) {
                      referencedVariable.referenceCount += 1
                      if (referencedVariable.id.type.multiplicity != 0L && referencedVariable.referenceCount > referencedVariable.id.type.multiplicity)
                        throw CustomJsonException("{${value.id.key.id.name}: 'Unable to reference variable due to variable's reference limit'}")
                      if (!referencedVariable.active)
                        throw CustomJsonException("{${value.id.key.id.name}: 'Unable to reference variable as it is inactive'}")
                      value.list!!.variables.add(referencedVariable)
                      value.list!!.size += 1
                    } else throw CustomJsonException("{${value.id.key.id.name}: {add: '${it.asJsonObject.get("variableName").asString} is already present in list'}}")
                  }
                }
                if (listValues.has("remove")) {
                  listValues.get("remove").asJsonArray.forEach {
                    val referencedVariable = variableRepository.findVariable(organizationName = type.id.organization.id, superTypeName = value.list!!.listType.type.id.superTypeName, typeName = value.list!!.listType.type.id.name, superList = it.asJsonObject.get("context").asLong, name = it.asJsonObject.get("variableName").asString)
                        ?: throw CustomJsonException("{${value.id.key.id.name}: {remove: 'Unable to remove ${it.asJsonObject.get("variableName").asString} referenced in list'}}")
                    if (value.list!!.variables.contains(referencedVariable)) {
                      referencedVariable.referenceCount -= 1
                      value.list!!.variables.remove(referencedVariable)
                      value.list!!.size -= 1
                      variableRepository.save(referencedVariable)
                    } else throw CustomJsonException("{${value.id.key.id.name}: {remove: '${it.asJsonObject.get("variableName").asString} is not present in list'}}")
                  }
                }
              }
            }
            if (value.list!!.size < value.list!!.listType.min)
              throw CustomJsonException("{${value.id.key.id.name}: 'List cannot contain less than ${value.list!!.listType.min} variables'}")
            if (value.list!!.listType.max != 0 && value.list!!.size > value.list!!.listType.max)
              throw CustomJsonException("{${value.id.key.id.name}: 'List cannot contain more than ${value.list!!.listType.max} variables'}")
          }
          else -> {
            if (value.id.key.type.id.superTypeName == GLOBAL_TYPE) {
              value.referencedVariable!!.referenceCount -= 1
              variableRepository.save(value.referencedVariable!!)
              val referencedVariable = variableRepository.findVariable(organizationName = type.id.organization.id, superTypeName = value.id.key.type.id.superTypeName, typeName = value.id.key.type.id.name, superList = type.id.organization.superList!!.id, name = values.get(value.id.key.id.name).asString)
                  ?: throw CustomJsonException("{${value.id.key.id.name}: 'Unable to find referenced variable ${values.get(value.id.key.id.name).asString}'}")
              referencedVariable.referenceCount += 1
              if (referencedVariable.id.type.multiplicity != 0L && referencedVariable.referenceCount > referencedVariable.id.type.multiplicity)
                throw CustomJsonException("{${value.id.key.id.name}: 'Unable to reference variable due to variable's reference limit'}")
              if (!referencedVariable.active)
                throw CustomJsonException("{${value.id.key.id.name}: 'Unable to reference variable as it is inactive'}")
              value.referencedVariable = referencedVariable
              if (value.id.key.isVariableDependency) {
                value.dependentValues.forEach {
                  if (!dependentFormulaValues.containsKey(it))
                    dependentFormulaValues[it] = mutableSetOf(value)
                  else
                    dependentFormulaValues[it]!!.add(value)
                }
              }
            } else {
              if ((value.id.key.id.parentType.id.superTypeName == GLOBAL_TYPE && value.id.key.id.parentType.id.name == value.id.key.type.id.superTypeName)
                  || (value.id.key.id.parentType.id.superTypeName != GLOBAL_TYPE && value.id.key.id.parentType.id.superTypeName == value.id.key.type.id.superTypeName)) {
                value.referencedVariable = try {
                  val (subVariable, subDependentFormulaValues) = updateVariable(jsonParams = values.get(value.id.key.id.name).asJsonObject, referencedKeyVariable = value.referencedVariable!!, variableTypePermission = typePermission.keyPermissions.single { keyPermission -> keyPermission.id.key.id.name == value.id.key.id.name }.referencedTypePermission!!, variableSuperList = value.referencedVariable!!.id.superList)
                  subDependentFormulaValues.forEach { (k, v) ->
                    if (!dependentFormulaValues.containsKey(k))
                      dependentFormulaValues[k] = v
                    else
                      dependentFormulaValues[k]!!.addAll(v)
                  }
                  subVariable
                } catch (exception: CustomJsonException) {
                  throw CustomJsonException("{${value.id.key.id.name}: ${exception.message}}")
                }
              } else {
                value.referencedVariable!!.referenceCount -= 1
                variableRepository.save(value.referencedVariable!!)
                val referencedVariable = variableRepository.findVariable(organizationName = type.id.organization.id, superTypeName = value.id.key.type.id.superTypeName, typeName = value.id.key.type.id.name, superList = values.get(value.id.key.id.name).asJsonObject.get("context").asLong, name = values.get(value.id.key.id.name).asJsonObject.get("variableName").asString)
                    ?: throw CustomJsonException("{${value.id.key.id.name}: 'Unable to find referenced variable ${values.get(value.id.key.id.name).asJsonObject.get("variableName").asString}'}")
                referencedVariable.referenceCount += 1
                if (referencedVariable.id.type.multiplicity != 0L && referencedVariable.referenceCount > referencedVariable.id.type.multiplicity)
                  throw CustomJsonException("{${value.id.key.id.name}: 'Unable to reference variable due to variable's reference limit'}")
                if (!referencedVariable.active)
                  throw CustomJsonException("{${value.id.key.id.name}: 'Unable to reference variable as it is inactive'}")
                value.referencedVariable = referencedVariable
                if (value.id.key.isVariableDependency) {
                  value.dependentValues.forEach {
                    if (!dependentFormulaValues.containsKey(it))
                      dependentFormulaValues[it] = mutableSetOf(value)
                    else
                      dependentFormulaValues[it]!!.add(value)
                  }
                }
              }
            }
          }
        }
      }
    }
    variable.values.filter { it.id.key.type.id.name == TypeConstants.FORMULA }.forEach { value ->
      if (dependentFormulaValues.contains(value)) {
        when (value.id.key.formula!!.returnType.id.name) {
          TypeConstants.TEXT -> {
            val evaluatedValue = validateOrEvaluateExpression(jsonParams = gson.fromJson(value.id.key.formula!!.expression, JsonObject::class.java).apply { addProperty("expectedReturnType", value.id.key.formula!!.returnType.id.name) },
                symbols = getSymbolValues(variable = variable, symbolPaths = gson.fromJson(value.id.key.formula!!.symbolPaths, JsonArray::class.java).map { it.asString }.toMutableSet()), mode = "evaluate") as String
            if (value.stringValue != evaluatedValue) {
              value.stringValue = evaluatedValue
              if (value.id.key.isDependency) {
                value.dependentValues.forEach {
                  if (!dependentFormulaValues.containsKey(it))
                    dependentFormulaValues[it] = mutableSetOf(value)
                  else
                    dependentFormulaValues[it]!!.add(value)
                }
              }
            }
          }
          TypeConstants.NUMBER -> {
            val evaluatedValue = validateOrEvaluateExpression(jsonParams = gson.fromJson(value.id.key.formula!!.expression, JsonObject::class.java).apply { addProperty("expectedReturnType", value.id.key.formula!!.returnType.id.name) },
                symbols = getSymbolValues(variable = variable, symbolPaths = gson.fromJson(value.id.key.formula!!.symbolPaths, JsonArray::class.java).map { it.asString }.toMutableSet()), mode = "evaluate") as Long
            if (value.longValue != evaluatedValue) {
              value.longValue = evaluatedValue
              if (value.id.key.isDependency) {
                value.dependentValues.forEach {
                  if (!dependentFormulaValues.containsKey(it))
                    dependentFormulaValues[it] = mutableSetOf(value)
                  else
                    dependentFormulaValues[it]!!.add(value)
                }
              }
            }
          }
          TypeConstants.DECIMAL -> {
            val evaluatedValue = validateOrEvaluateExpression(jsonParams = gson.fromJson(value.id.key.formula!!.expression, JsonObject::class.java).apply { addProperty("expectedReturnType", value.id.key.formula!!.returnType.id.name) },
                symbols = getSymbolValues(variable = variable, symbolPaths = gson.fromJson(value.id.key.formula!!.symbolPaths, JsonArray::class.java).map { it.asString }.toMutableSet()), mode = "evaluate") as Double
            if (value.doubleValue != evaluatedValue) {
              value.doubleValue = evaluatedValue
              if (value.id.key.isDependency) {
                value.dependentValues.forEach {
                  if (!dependentFormulaValues.containsKey(it))
                    dependentFormulaValues[it] = mutableSetOf(value)
                  else
                    dependentFormulaValues[it]!!.add(value)
                }
              }
            }
          }
          TypeConstants.BOOLEAN -> {
            val evaluatedValue = validateOrEvaluateExpression(jsonParams = gson.fromJson(value.id.key.formula!!.expression, JsonObject::class.java).apply { addProperty("expectedReturnType", value.id.key.formula!!.returnType.id.name) },
                symbols = getSymbolValues(variable = variable, symbolPaths = gson.fromJson(value.id.key.formula!!.symbolPaths, JsonArray::class.java).map { it.asString }.toMutableSet()), mode = "evaluate") as Boolean
            if (value.booleanValue != evaluatedValue) {
              value.booleanValue = evaluatedValue
              if (value.id.key.isDependency) {
                value.dependentValues.forEach {
                  if (!dependentFormulaValues.containsKey(it))
                    dependentFormulaValues[it] = mutableSetOf(value)
                  else
                    dependentFormulaValues[it]!!.add(value)
                }
              }
            }
          }
          else -> throw CustomJsonException("{${value.id.key.id.name}: 'Unable to compute formula value'}")
        }
        dependentFormulaValues.remove(value)
      }
    }
    if (jsonParams.has("updatedVariableName?"))
      variable.id.name = jsonParams.get("updatedVariableName?").asString
    try {
      variableRepository.save(variable)
    } catch (exception: Exception) {
      throw CustomJsonException("{variableName: 'Variable could not be updated'}")
    }
    if (variable.id.type.id.superTypeName == GLOBAL_TYPE && dependentFormulaValues.isNotEmpty())
      recomputeDependentFormulaValues(dependentFormulaValues)
    return Pair(variable, dependentFormulaValues)
  }

  @Transactional(rollbackFor = [CustomJsonException::class])
  fun recomputeDependentFormulaValues(dependentFormulaValues: MutableMap<Value, MutableSet<Value>>) {
    val higherDependentFormulaValues: MutableMap<Value, MutableSet<Value>> = mutableMapOf()
    dependentFormulaValues.forEach { (value, dependencies) ->
      when (value.id.key.formula!!.returnType.id.name) {
        TypeConstants.TEXT -> {
          val reconstructDependencies: Boolean = dependencies.fold(false) { acc, v -> acc || v.id.key.isVariableDependency }
          if (reconstructDependencies) {
            val valueDependencies: MutableSet<Value> = mutableSetOf()
            value.stringValue = validateOrEvaluateExpression(jsonParams = gson.fromJson(value.id.key.formula!!.expression, JsonObject::class.java).apply { addProperty("expectedReturnType", value.id.key.formula!!.returnType.id.name) },
                symbols = getSymbolValuesAndUpdateDependencies(variable = value.id.variable, symbolPaths = gson.fromJson(value.id.key.formula!!.symbolPaths, JsonArray::class.java).map { it.asString }.toMutableSet(), valueDependencies = valueDependencies), mode = "evaluate") as String
            value.valueDependencies = valueDependencies
            valueRepository.save(value)
            if (value.id.key.isDependency) {
              value.dependentValues.forEach {
                if (!higherDependentFormulaValues.containsKey(it))
                  higherDependentFormulaValues[it] = mutableSetOf(value)
                else
                  higherDependentFormulaValues[it]!!.add(value)
              }
            }
          } else {
            val evaluatedValue = validateOrEvaluateExpression(jsonParams = gson.fromJson(value.id.key.formula!!.expression, JsonObject::class.java).apply { addProperty("expectedReturnType", value.id.key.formula!!.returnType.id.name) },
                symbols = getSymbolValues(variable = value.id.variable, symbolPaths = gson.fromJson(value.id.key.formula!!.symbolPaths, JsonArray::class.java).map { it.asString }.toMutableSet()), mode = "evaluate") as String
            if (value.stringValue != evaluatedValue) {
              value.stringValue = evaluatedValue
              if (value.id.key.isDependency) {
                value.dependentValues.forEach {
                  if (!higherDependentFormulaValues.containsKey(it))
                    higherDependentFormulaValues[it] = mutableSetOf(value)
                  else
                    higherDependentFormulaValues[it]!!.add(value)
                }
              }
            }
          }
        }
        TypeConstants.NUMBER -> {
          val reconstructDependencies: Boolean = dependencies.fold(false) { acc, v -> acc || v.id.key.isVariableDependency }
          if (reconstructDependencies) {
            val valueDependencies: MutableSet<Value> = mutableSetOf()
            value.longValue = validateOrEvaluateExpression(jsonParams = gson.fromJson(value.id.key.formula!!.expression, JsonObject::class.java).apply { addProperty("expectedReturnType", value.id.key.formula!!.returnType.id.name) },
                symbols = getSymbolValuesAndUpdateDependencies(variable = value.id.variable, symbolPaths = gson.fromJson(value.id.key.formula!!.symbolPaths, JsonArray::class.java).map { it.asString }.toMutableSet(), valueDependencies = valueDependencies), mode = "evaluate") as Long
            value.valueDependencies = valueDependencies
            valueRepository.save(value)
            if (value.id.key.isDependency) {
              value.dependentValues.forEach {
                if (!higherDependentFormulaValues.containsKey(it))
                  higherDependentFormulaValues[it] = mutableSetOf(value)
                else
                  higherDependentFormulaValues[it]!!.add(value)
              }
            }
          } else {
            val evaluatedValue = validateOrEvaluateExpression(jsonParams = gson.fromJson(value.id.key.formula!!.expression, JsonObject::class.java).apply { addProperty("expectedReturnType", value.id.key.formula!!.returnType.id.name) },
                symbols = getSymbolValues(variable = value.id.variable, symbolPaths = gson.fromJson(value.id.key.formula!!.symbolPaths, JsonArray::class.java).map { it.asString }.toMutableSet()), mode = "evaluate") as Long
            if (value.longValue != evaluatedValue) {
              value.longValue = evaluatedValue
              if (value.id.key.isDependency) {
                value.dependentValues.forEach {
                  if (!higherDependentFormulaValues.containsKey(it))
                    higherDependentFormulaValues[it] = mutableSetOf(value)
                  else
                    higherDependentFormulaValues[it]!!.add(value)
                }
              }
            }
          }
        }
        TypeConstants.DECIMAL -> {
          val reconstructDependencies: Boolean = dependencies.fold(false) { acc, v -> acc || v.id.key.isVariableDependency }
          if (reconstructDependencies) {
            val valueDependencies: MutableSet<Value> = mutableSetOf()
            value.doubleValue = validateOrEvaluateExpression(jsonParams = gson.fromJson(value.id.key.formula!!.expression, JsonObject::class.java).apply { addProperty("expectedReturnType", value.id.key.formula!!.returnType.id.name) },
                symbols = getSymbolValuesAndUpdateDependencies(variable = value.id.variable, symbolPaths = gson.fromJson(value.id.key.formula!!.symbolPaths, JsonArray::class.java).map { it.asString }.toMutableSet(), valueDependencies = valueDependencies), mode = "evaluate") as Double
            value.valueDependencies = valueDependencies
            valueRepository.save(value)
            if (value.id.key.isDependency) {
              value.dependentValues.forEach {
                if (!higherDependentFormulaValues.containsKey(it))
                  higherDependentFormulaValues[it] = mutableSetOf(value)
                else
                  higherDependentFormulaValues[it]!!.add(value)
              }
            }
          } else {
            val evaluatedValue = validateOrEvaluateExpression(jsonParams = gson.fromJson(value.id.key.formula!!.expression, JsonObject::class.java).apply { addProperty("expectedReturnType", value.id.key.formula!!.returnType.id.name) },
                symbols = getSymbolValues(variable = value.id.variable, symbolPaths = gson.fromJson(value.id.key.formula!!.symbolPaths, JsonArray::class.java).map { it.asString }.toMutableSet()), mode = "evaluate") as Double
            if (value.doubleValue != evaluatedValue) {
              value.doubleValue = evaluatedValue
              if (value.id.key.isDependency) {
                value.dependentValues.forEach {
                  if (!higherDependentFormulaValues.containsKey(it))
                    higherDependentFormulaValues[it] = mutableSetOf(value)
                  else
                    higherDependentFormulaValues[it]!!.add(value)
                }
              }
            }
          }
        }
        TypeConstants.BOOLEAN -> {
          val reconstructDependencies: Boolean = dependencies.fold(false) { acc, v -> acc || v.id.key.isVariableDependency }
          if (reconstructDependencies) {
            val valueDependencies: MutableSet<Value> = mutableSetOf()
            value.booleanValue = validateOrEvaluateExpression(jsonParams = gson.fromJson(value.id.key.formula!!.expression, JsonObject::class.java).apply { addProperty("expectedReturnType", value.id.key.formula!!.returnType.id.name) },
                symbols = getSymbolValuesAndUpdateDependencies(variable = value.id.variable, symbolPaths = gson.fromJson(value.id.key.formula!!.symbolPaths, JsonArray::class.java).map { it.asString }.toMutableSet(), valueDependencies = valueDependencies), mode = "evaluate") as Boolean
            value.valueDependencies = valueDependencies
            valueRepository.save(value)
            if (value.id.key.isDependency) {
              value.dependentValues.forEach {
                if (!higherDependentFormulaValues.containsKey(it))
                  higherDependentFormulaValues[it] = mutableSetOf(value)
                else
                  higherDependentFormulaValues[it]!!.add(value)
              }
            }
          } else {
            val evaluatedValue = validateOrEvaluateExpression(jsonParams = gson.fromJson(value.id.key.formula!!.expression, JsonObject::class.java).apply { addProperty("expectedReturnType", value.id.key.formula!!.returnType.id.name) },
                symbols = getSymbolValues(variable = value.id.variable, symbolPaths = gson.fromJson(value.id.key.formula!!.symbolPaths, JsonArray::class.java).map { it.asString }.toMutableSet()), mode = "evaluate") as Boolean
            if (value.booleanValue != evaluatedValue) {
              value.booleanValue = evaluatedValue
              if (value.id.key.isDependency) {
                value.dependentValues.forEach {
                  if (!higherDependentFormulaValues.containsKey(it))
                    higherDependentFormulaValues[it] = mutableSetOf(value)
                  else
                    higherDependentFormulaValues[it]!!.add(value)
                }
              }
            }
          }
        }
        else -> throw CustomJsonException("{error: 'Unable to compute dependent formula value'}")
      }
    }
    valueRepository.saveAll(dependentFormulaValues.keys)
    if (higherDependentFormulaValues.isNotEmpty())
      recomputeDependentFormulaValues(higherDependentFormulaValues)
  }
}
