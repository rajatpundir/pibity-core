/* 
 * Copyright (C) 2020 Pibity Infotech Private Limited - All Rights Reserved
 * Unauthorized copying of this file, via any medium is strictly prohibited
 * Proprietary and confidential
 * THIS IS UNPUBLISHED PROPRIETARY CODE OF PIBITY INFOTECH PRIVATE LIMITED
 * The copyright notice above does not evidence any actual or intended publication of such source code.
 */

package com.pibity.erp.services

import com.google.gson.JsonArray
import com.google.gson.JsonObject
import com.pibity.erp.commons.FormulaUtils
import com.pibity.erp.commons.constants.KeyConstants
import com.pibity.erp.commons.constants.TypeConstants
import com.pibity.erp.commons.constants.primitiveTypes
import com.pibity.erp.commons.exceptions.CustomJsonException
import com.pibity.erp.commons.getLeafNameTypeValues
import com.pibity.erp.commons.validateUpdatedVariableValues
import com.pibity.erp.commons.validateVariableValues
import com.pibity.erp.entities.*
import com.pibity.erp.entities.embeddables.ValueId
import com.pibity.erp.entities.embeddables.VariableId
import com.pibity.erp.repositories.OrganizationRepository
import com.pibity.erp.repositories.TypeRepository
import com.pibity.erp.repositories.VariableRepository
import org.codehaus.janino.ExpressionEvaluator
import org.springframework.stereotype.Service
import org.springframework.transaction.annotation.Transactional

@Service
class VariableService(
    val organizationRepository: OrganizationRepository,
    val typeRepository: TypeRepository,
    val variableRepository: VariableRepository
) {

  @Transactional(rollbackFor = [CustomJsonException::class])
  fun createVariable(jsonParams: JsonObject): Variable {
    val organizationName: String = jsonParams.get("organization").asString
    val typeName: String = jsonParams.get("typeName").asString
    val superTypeName: String = if (jsonParams.has("superTypeName")) jsonParams.get("superTypeName").asString else "Any"
    val variableName: String = if (superTypeName == "Any") "" else jsonParams.get("variableName").asString
    val superVariableName: String = if (jsonParams.has("superVariableName")) jsonParams.get("superVariableName").asString else jsonParams.get("variableName").asString
    val organization: Organization = organizationRepository.findById(organizationName)
        ?: throw CustomJsonException("{organization: 'Organization could not be found'}")
    val type: Type = typeRepository.findType(organization = organization, superTypeName = superTypeName, name = typeName)
        ?: throw CustomJsonException("{typeName: 'Type could not be determined'}")
    val values: JsonObject = validateVariableValues(values = jsonParams.get("values").asJsonObject, type = type)
    val variable = Variable(
        id = VariableId(type = type,
            superVariableName = superVariableName,
            name = if (type.id.superTypeName == "Any" && type.autoAssignId) (type.autoIncrementId + 1).toString() else variableName),
        autoGeneratedId = type.autoIncrementId + 1)
    variable.id.type.autoIncrementId += 1
    // Process non-formula type values
    type.keys.filter { it.type.id.name != TypeConstants.FORMULA }.forEach {
      when (it.type.id.name) {
        TypeConstants.TEXT -> variable.values.add(Value(id = ValueId(variable = variable, key = it), stringValue = values.get(it.id.name).asString))
        TypeConstants.NUMBER -> variable.values.add(Value(id = ValueId(variable = variable, key = it), longValue = values.get(it.id.name).asLong))
        TypeConstants.DECIMAL -> variable.values.add(Value(id = ValueId(variable = variable, key = it), doubleValue = values.get(it.id.name).asDouble))
        TypeConstants.BOOLEAN -> variable.values.add(Value(id = ValueId(variable = variable, key = it), booleanValue = values.get(it.id.name).asBoolean))
        TypeConstants.FORMULA -> {/* Formulas may depend on provided values, so they will be computed separately */
        }
        TypeConstants.LIST -> {
          val jsonArray: JsonArray = values.get(it.id.name).asJsonArray
          val list = VariableList(listType = it.list!!)
          for (ref in jsonArray.iterator()) {
            // Key type is reference to non-primitive type
            if (it.type.id.superTypeName == "Any") {
              // key is reference to global type
              if (ref.isJsonObject) {
                val referencedVariable: Variable = try {
                  createVariable(JsonObject().apply {
                    addProperty("organization", organizationName)
                    addProperty("superTypeName", it.list!!.type.id.superTypeName)
                    addProperty("typeName", it.list!!.type.id.name)
                    addProperty("superVariableName", superVariableName)
                    addProperty("variableName", ref.asJsonObject.get("variableName").asString)
                    add("values", ref.asJsonObject.get("values").asJsonObject)
                  })
                } catch (exception: CustomJsonException) {
                  throw CustomJsonException("{${it.id.name}: ${exception.message}}")
                }
                list.variables.add(referencedVariable)
              } else {
                val referencedVariable: Variable = variableRepository.findByTypeAndName(type = it.type, superVariableName = ref.asString)
                    ?: throw CustomJsonException("{${it.id.name}: 'Unable to find referenced global variable'}")
                list.variables.add(referencedVariable)
              }
            } else {
              if ((it.id.parentType.id.superTypeName == "Any" && it.id.parentType.id.name == it.type.id.superTypeName)
                  || (it.id.parentType.id.superTypeName != "Any" && it.id.parentType.id.superTypeName == it.type.id.superTypeName)) {
                // key is internally reference to local type
                // Internally local type variables can only be created not referenced.
                if (ref.isJsonObject) {
                  val referencedVariable: Variable = try {
                    createVariable(JsonObject().apply {
                      addProperty("organization", organizationName)
                      addProperty("superTypeName", it.list!!.type.id.superTypeName)
                      addProperty("typeName", it.list!!.type.id.name)
                      addProperty("superVariableName", superVariableName)
                      addProperty("variableName", ref.asJsonObject.get("variableName").asString)
                      add("values", ref.asJsonObject.get("values").asJsonObject)
                    })
                  } catch (exception: CustomJsonException) {
                    throw CustomJsonException("{${it.id.name}: ${exception.message}}")
                  }
                  list.variables.add(referencedVariable)
                } else {
                  val referencedVariable: Variable = variableRepository.findByTypeAndName(type = it.type, superVariableName = ref.asString)
                      ?: throw CustomJsonException("{${it.id.name}: 'Unable to find referenced local field of global variable'}")
                  list.variables.add(referencedVariable)
                }
              } else {
                // key is externally reference to some local type
                // Only referencing makes sense for this case.
                if (ref.isJsonObject) {
                  val referencedVariable: Variable = variableRepository.findByTypeAndName(type = it.type,
                      superVariableName = ref.asJsonObject.get("variableName").asString,
                      name = if (ref.asJsonObject.has("localVariableName"))
                        ref.asJsonObject.get("localVariableName").asString else "")
                      ?: throw CustomJsonException("{${it.id.name}: 'Unable to find referenced local field of global variable'}")
                  list.variables.add(referencedVariable)
                } else {
                  val referencedVariable: Variable = variableRepository.findByTypeAndName(type = it.type, superVariableName = ref.asString)
                      ?: throw CustomJsonException("{${it.id.name}: 'Unable to find referenced local field of global variable'}")
                  list.variables.add(referencedVariable)
                }
              }
            }
          }
          variable.values.add(Value(id = ValueId(variable = variable, key = it), list = list))
        }
        else -> {
          // Key type is reference to non-primitive type
          if (it.type.id.superTypeName == "Any") {
            // key is reference to global type
            if (values.get(it.id.name).isJsonObject) {
              val referencedVariable: Variable = try {
                createVariable(JsonObject().apply {
                  addProperty("organization", organizationName)
                  addProperty("superTypeName", it.type.id.superTypeName)
                  addProperty("typeName", it.type.id.name)
                  addProperty("variableName", values.get(it.id.name).asJsonObject.get("variableName").asString)
                  add("values", values.get(it.id.name).asJsonObject.get("values").asJsonObject)
                })
              } catch (exception: CustomJsonException) {
                throw CustomJsonException("{${it.id.name}: ${exception.message}}")
              }
              variable.values.add(Value(id = ValueId(variable = variable, key = it), referencedVariable = referencedVariable))
            } else {
              val referencedVariable: Variable = variableRepository.findByTypeAndName(type = it.type, superVariableName = values.get(it.id.name).asString)
                  ?: throw CustomJsonException("{${it.id.name}: 'Unable to find referenced global variable'}")
              variable.values.add(Value(id = ValueId(variable = variable, key = it), referencedVariable = referencedVariable))
            }
          } else {
            if ((it.id.parentType.id.superTypeName == "Any" && it.id.parentType.id.name == it.type.id.superTypeName)
                || (it.id.parentType.id.superTypeName != "Any" && it.id.parentType.id.superTypeName == it.type.id.superTypeName)) {
              // key is internally reference to local type
              // Internally local type variables can only be created not referenced.
              if (values.get(it.id.name).isJsonObject) {
                val referencedVariable: Variable = try {
                  createVariable(JsonObject().apply {
                    addProperty("organization", organizationName)
                    addProperty("superTypeName", it.type.id.superTypeName)
                    addProperty("typeName", it.type.id.name)
                    addProperty("superVariableName", superVariableName)
                    addProperty("variableName", "")
                    add("values", values.get(it.id.name).asJsonObject.get("values").asJsonObject)
                  })
                } catch (exception: CustomJsonException) {
                  throw CustomJsonException("{${it.id.name}: ${exception.message}}")
                }
                variable.values.add(Value(id = ValueId(variable = variable, key = it), referencedVariable = referencedVariable))
              } else {
                val referencedVariable: Variable = variableRepository.findByTypeAndName(type = it.type, superVariableName = values.get(it.id.name).asString)
                    ?: throw CustomJsonException("{${it.id.name}: 'Unable to find referenced local variable'}")
                variable.values.add(Value(id = ValueId(variable = variable, key = it), referencedVariable = referencedVariable))
              }
            } else {
              // key is externally reference to some local type
              // Only referencing makes sense for this case.
              if (values.get(it.id.name).isJsonObject) {
                val referencedVariable: Variable = variableRepository.findByTypeAndName(type = it.type,
                    superVariableName = values.get(it.id.name).asJsonObject.get("variableName").asString,
                    name = if (values.get(it.id.name).asJsonObject.has("localVariableName"))
                      values.get(it.id.name).asJsonObject.get("localVariableName").asString else "")
                    ?: throw CustomJsonException("{${it.id.name}: 'Unable to find referenced local field of global variable'}")
                variable.values.add(Value(id = ValueId(variable = variable, key = it), referencedVariable = referencedVariable))
              } else {
                val referencedVariable: Variable = variableRepository.findByTypeAndName(type = it.type, superVariableName = values.get(it.id.name).asString)
                    ?: throw CustomJsonException("{${it.id.name}: 'Unable to find referenced local field of global variable'}")
                variable.values.add(Value(id = ValueId(variable = variable, key = it), referencedVariable = referencedVariable))
              }
            }
          }
        }
      }
    }
    // Process formula type values
    type.keys.filter { it.type.id.name == TypeConstants.FORMULA }.forEach {
      val expression: String = it.formula?.expression
          ?: throw CustomJsonException("{${it.id.name}: 'Unable to process formula'}")
      val returnTypeName: String = it.formula!!.returnType.id.name
      val leafKeyTypeAndValues: Map<String, Map<String, String>> = getLeafNameTypeValues(prefix = null, keys = mutableMapOf(), variable = variable, depth = 0)
      val injectedVariables: Array<String?> = arrayOfNulls(leafKeyTypeAndValues.size)
      val injectedClasses: Array<Class<*>?> = arrayOfNulls(leafKeyTypeAndValues.size)
      val injectedObjects: Array<Any?> = arrayOfNulls(leafKeyTypeAndValues.size)
      var index = 0
      for ((key, value) in leafKeyTypeAndValues) {
        injectedVariables[index] = key
        when (value[KeyConstants.KEY_TYPE]) {
          TypeConstants.TEXT -> {
            injectedClasses[index] = String::class.javaObjectType
            injectedObjects[index] = value[KeyConstants.VALUE]
          }
          TypeConstants.NUMBER -> {
            injectedClasses[index] = Long::class.javaObjectType
            injectedObjects[index] = value[KeyConstants.VALUE]?.toLong()
          }
          TypeConstants.DECIMAL -> {
            injectedClasses[index] = Double::class.javaObjectType
            injectedObjects[index] = value[KeyConstants.VALUE]?.toDouble()
          }
          TypeConstants.BOOLEAN -> {
            injectedClasses[index] = Boolean::class.javaObjectType
            injectedObjects[index] = value[KeyConstants.VALUE]?.toBoolean()
          }
        }
        index += 1
      }
      val evaluator = ExpressionEvaluator()
      evaluator.setParameters(injectedVariables, injectedClasses)
      when (returnTypeName) {
        TypeConstants.TEXT -> {
          evaluator.setExpressionType(String::class.javaObjectType)
          // Check expression for any compilation errors
          try {
            evaluator.cook(expression)
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.name}: 'Unable to parse formula expression'}")
          }
          // Evaluate expression and get back result
          try {
            variable.values.add(Value(id = ValueId(variable = variable, key = it), stringValue = FormulaUtils.evaluateExpression(evaluator, injectedObjects) as String))
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.name}: 'Formula expression resulted in error'}")
          }
        }
        TypeConstants.NUMBER -> {
          evaluator.setExpressionType(Long::class.javaObjectType)
          try {
            evaluator.cook(expression)
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.name}: 'Unable to parse formula expression'}")
          }
          try {
            variable.values.add(Value(id = ValueId(variable = variable, key = it), longValue = FormulaUtils.evaluateExpression(evaluator, injectedObjects) as Long))
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.name}: 'Formula expression resulted in error'}")
          }
        }
        TypeConstants.DECIMAL -> {
          evaluator.setExpressionType(Double::class.javaObjectType)
          try {
            evaluator.cook(expression)
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.name}: 'Unable to parse formula expression'}")
          }
          try {
            variable.values.add(Value(id = ValueId(variable = variable, key = it), doubleValue = FormulaUtils.evaluateExpression(evaluator, injectedObjects) as Double))
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.name}: 'Formula expression resulted in error'}")
          }
        }
        TypeConstants.BOOLEAN -> {
          evaluator.setExpressionType(Boolean::class.javaObjectType)
          try {
            evaluator.cook(expression)
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.name}: 'Unable to parse formula expression'}")
          }
          try {
            variable.values.add(Value(id = ValueId(variable = variable, key = it), booleanValue = FormulaUtils.evaluateExpression(evaluator, injectedObjects) as Boolean))
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.name}: 'Formula expression resulted in error'}")
          }
        }
      }
    }
    return try {
      // TODO: This should fail if variable is already present.
      // But that is not the case right now.
      variableRepository.save(variable)
    } catch (exception: Exception) {
      throw CustomJsonException("{variableName: 'Variable could not be created'}")
    }
  }

  @Transactional(rollbackFor = [CustomJsonException::class])
  fun getVariableDetails(jsonParams: JsonObject): Variable {
    val organizationName: String = jsonParams.get("organization").asString
    val typeName: String = jsonParams.get("typeName").asString
    val variableName: String = jsonParams.get("variableName").asString
    return variableRepository.findVariable(organizationName = organizationName, superTypeName = "Any", typeName = typeName, superVariableName = variableName)
        ?: throw CustomJsonException("{variableName: 'Unable to find referenced variable'}")
  }

  @Transactional(rollbackFor = [CustomJsonException::class])
  fun updateLocalVariableNames(variable: Variable, updatedVariableName: String) {
    variable.id.superVariableName = updatedVariableName
    variable.values.filter { it.id.key.type.id.name !in primitiveTypes }.forEach { value ->
      when (value.id.key.type.id.name) {
        TypeConstants.LIST -> {
          if (value.list!!.listType.type.id.superTypeName != "Any") {
            if ((value.id.key.id.parentType.id.superTypeName == "Any" && value.id.key.id.parentType.id.name == value.list!!.listType.type.id.superTypeName)
                || (value.id.key.id.parentType.id.superTypeName != "Any" && value.id.key.id.parentType.id.superTypeName == value.list!!.listType.type.id.superTypeName)) {
              value.list!!.variables.forEach {
                updateLocalVariableNames(variable = it, updatedVariableName = updatedVariableName)
              }
            }
          }
        }
        else -> {
          if ((value.id.key.id.parentType.id.superTypeName == "Any" && value.id.key.id.parentType.id.name == value.id.key.type.id.superTypeName)
              || (value.id.key.id.parentType.id.superTypeName != "Any" && value.id.key.id.parentType.id.superTypeName == value.id.key.type.id.superTypeName)) {
            updateLocalVariableNames(variable = value.referencedVariable!!, updatedVariableName = updatedVariableName)
          }
        }
      }
    }
  }

  @Transactional(rollbackFor = [CustomJsonException::class])
  fun updateVariable(jsonParams: JsonObject): Variable {
    val organizationName: String = jsonParams.get("organization").asString
    val typeName: String = jsonParams.get("typeName").asString
    val variableName: String = jsonParams.get("variableName").asString
    val superTypeName: String = if (jsonParams.has("superTypeName")) jsonParams.get("superTypeName").asString else "Any"
    val variable: Variable = variableRepository.findVariable(organizationName = organizationName, superTypeName = superTypeName, typeName = typeName, superVariableName = variableName)
        ?: throw CustomJsonException("{variableName: 'Unable to find referenced variable'}")
    val values: JsonObject = validateUpdatedVariableValues(values = jsonParams.get("values").asJsonObject, type = variable.id.type)
    // Process non-formula type values
    variable.values.filter { it.id.key.type.id.name != TypeConstants.FORMULA }.forEach { value ->
      if (values.has(value.id.key.id.name)) {
        when (value.id.key.type.id.name) {
          TypeConstants.TEXT -> value.stringValue = values.get(value.id.key.id.name).asString
          TypeConstants.NUMBER -> value.longValue = values.get(value.id.key.id.name).asLong
          TypeConstants.DECIMAL -> value.doubleValue = values.get(value.id.key.id.name).asDouble
          TypeConstants.BOOLEAN -> value.booleanValue = values.get(value.id.key.id.name).asBoolean
          TypeConstants.FORMULA -> {/* Formulas may depend on provided values, so they will be computed separately */
          }
          TypeConstants.LIST -> {
            val listValues: JsonObject = values.get(value.id.key.id.name).asJsonObject
            if (listValues.has("add")) {
              listValues.get("add").asJsonArray.forEach {
                if (it.isJsonObject) {
                  val referencedVariable: Variable = createVariable(
                      it.asJsonObject.apply {
                        addProperty("organization", organizationName)
                        addProperty("superTypeName", value.list!!.listType.type.id.superTypeName)
                        addProperty("typeName", value.list!!.listType.type.id.name)
                      }
                  )
                  value.list!!.variables.add(referencedVariable)
                } else {
                  val referencedVariable: Variable = variableRepository.findByTypeAndName(type = value.list!!.listType.type, superVariableName = it.asString)
                      ?: throw CustomJsonException("{${value.id.key.id.name}: 'Unable to insert ${it.asString} referenced in list'}")
                  value.list!!.variables.add(referencedVariable)
                }
              }
            }
            if (listValues.has("remove")) {
              listValues.get("remove").asJsonArray.forEach {
                val referencedVariable: Variable = variableRepository.findByTypeAndName(type = value.list!!.listType.type, superVariableName = it.asString)
                    ?: throw CustomJsonException("{${value.id.key.id.name}: 'Unable to insert ${it.asString} referenced in list'}")
                value.list!!.variables.remove(referencedVariable)
                // TODO: variable should also be deleted if its local and nt being used elsewhere.
              }
            }
          }
          else -> {
            if (value.id.key.type.id.superTypeName == "Any") {
              // value is reference to some global variable
              if (values.get(value.id.key.id.name).isJsonObject) {
                val variableJson: JsonObject = values.get(value.id.key.id.name).asJsonObject
                try {
                  value.referencedVariable = createVariable(JsonObject().apply {
                    addProperty("organization", organizationName)
                    addProperty("typeName", value.id.key.type.id.name)
                    addProperty("variableName", variableJson.get("variableName").asString)
                    add("values", variableJson.get("values").asJsonObject)
                  })
                } catch (exception: Exception) {
                  throw CustomJsonException("{${value.id.key.id.name}: 'Unable to create variable'}")
                }
              } else {
                value.referencedVariable = variableRepository.findByTypeAndName(type = value.id.key.type, superVariableName = values.get(value.id.key.id.name).asString)
                    ?: throw CustomJsonException("{${value.id.key.id.name}: 'Unable to find referenced variable'}")
              }
            } else {
              // value must refer to variable's own local state (internally, not externally to some local state of other global variable)
              if ((value.id.key.id.parentType.id.superTypeName == "Any" && value.id.key.id.parentType.id.name == value.id.key.type.id.superTypeName)
                  || (value.id.key.id.parentType.id.superTypeName != "Any" && value.id.key.id.parentType.id.superTypeName == value.id.key.type.id.superTypeName)) {
                val variableJson: JsonObject = values.get(value.id.key.id.name).asJsonObject
                value.referencedVariable = updateVariable(JsonObject().apply {
                  addProperty("organization", organizationName)
                  addProperty("superTypeName", value.id.key.type.id.superTypeName)
                  addProperty("typeName", value.id.key.type.id.name)
                  addProperty("variableName", variable.id.superVariableName)
                  add("values", variableJson.get("values").asJsonObject)
                })
              }
            }
          }
        }
      }
    }
    // Process formula type values
    // Recompute formula values
    // TODO: To be optimized in future so that formula is computed only upon change in dependent fields
    variable.values.filter { it.id.key.type.id.name == TypeConstants.FORMULA }.forEach {
      val expression: String = it.id.key.formula!!.expression
      val returnTypeName: String = it.id.key.formula!!.returnType.id.name
      val leafKeyTypeAndValues: Map<String, Map<String, String>> = getLeafNameTypeValues(prefix = null, keys = mutableMapOf(), variable = variable, depth = 0)
      val injectedVariables: Array<String?> = arrayOfNulls(leafKeyTypeAndValues.size)
      val injectedClasses: Array<Class<*>?> = arrayOfNulls(leafKeyTypeAndValues.size)
      val injectedObjects: Array<Any?> = arrayOfNulls(leafKeyTypeAndValues.size)
      var index = 0
      for ((key, value) in leafKeyTypeAndValues) {
        injectedVariables[index] = key
        when (value[KeyConstants.KEY_TYPE]) {
          TypeConstants.TEXT -> {
            injectedClasses[index] = String::class.javaObjectType
            injectedObjects[index] = value[KeyConstants.VALUE]
          }
          TypeConstants.NUMBER -> {
            injectedClasses[index] = Long::class.javaObjectType
            injectedObjects[index] = value[KeyConstants.VALUE]?.toLong()
          }
          TypeConstants.DECIMAL -> {
            injectedClasses[index] = Double::class.javaObjectType
            injectedObjects[index] = value[KeyConstants.VALUE]?.toDouble()
          }
          TypeConstants.BOOLEAN -> {
            injectedClasses[index] = Boolean::class.javaObjectType
            injectedObjects[index] = value[KeyConstants.VALUE]?.toBoolean()
          }
        }
        index += 1
      }
      val evaluator = ExpressionEvaluator()
      evaluator.setParameters(injectedVariables, injectedClasses)
      when (returnTypeName) {
        TypeConstants.TEXT -> {
          evaluator.setExpressionType(String::class.javaObjectType)
          // Check expression for any compilation errors
          try {
            evaluator.cook(expression)
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.key.id.name}: 'Unable to parse formula expression'}")
          }
          // Evaluate expression and get back result
          try {
            it.stringValue = FormulaUtils.evaluateExpression(evaluator, injectedObjects) as String
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.key.id.name}: 'Formula expression resulted in error'}")
          }
        }
        TypeConstants.NUMBER -> {
          evaluator.setExpressionType(Long::class.javaObjectType)
          try {
            evaluator.cook(expression)
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.key.id.name}: 'Unable to parse formula expression'}")
          }
          try {
            it.longValue = FormulaUtils.evaluateExpression(evaluator, injectedObjects) as Long
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.key.id.name}: 'Formula expression resulted in error'}")
          }
        }
        TypeConstants.DECIMAL -> {
          evaluator.setExpressionType(Double::class.javaObjectType)
          try {
            evaluator.cook(expression)
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.key.id.name}: 'Unable to parse formula expression'}")
          }
          try {
            it.doubleValue = FormulaUtils.evaluateExpression(evaluator, injectedObjects) as Double
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.key.id.name}: 'Formula expression resulted in error'}")
          }
        }
        TypeConstants.BOOLEAN -> {
          evaluator.setExpressionType(Boolean::class.javaObjectType)
          try {
            evaluator.cook(expression)
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.key.id.name}: 'Unable to parse formula expression'}")
          }
          try {
            it.booleanValue = FormulaUtils.evaluateExpression(evaluator, injectedObjects) as Boolean
          } catch (exception: Exception) {
            throw CustomJsonException("{${it.id.key.id.name}: 'Formula expression resulted in error'}")
          }
        }
      }
    }
    if (jsonParams.has("updatedVariableName?"))
      updateLocalVariableNames(variable = variable, updatedVariableName = jsonParams.get("updatedVariableName?").asString)
    try {
      variableRepository.save(variable)
    } catch (exception: Exception) {
      throw CustomJsonException("{variableName: 'Variable could not be updated'}")
    }
    return variable
  }

  @Transactional(rollbackFor = [CustomJsonException::class])
  fun searchVariables(jsonParams: JsonObject): Set<Variable> {
    val organizationName: String = jsonParams.get("organization").asString
    val typeName: String = jsonParams.get("typeName").asString
    val variableName: String = jsonParams.get("variableName").asString
    val organization: Organization = organizationRepository.findById(organizationName)
        ?: throw CustomJsonException("{organization: 'Organization could not be found'}")
    val type: Type = typeRepository.findType(organization = organization, superTypeName = "Any", name = typeName)
        ?: throw CustomJsonException("{typeName: 'Type could not be determined'}")
    return variableRepository.findBySimilarNames(type, variableName)
  }
}
